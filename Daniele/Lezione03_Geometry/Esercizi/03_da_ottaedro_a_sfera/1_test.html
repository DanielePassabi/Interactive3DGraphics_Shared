<html>

<head>
	<title>Ottaedro</title>
	<style>
		body {
			font-family: Monospace;
			background-color: #baf2ea;
			margin: 0px;
			overflow: hidden;
		}
		canvas {
			width: 100%;
			height: 100%;
		}
	</style>
	<script src="../../../lib/three.min.js"></script>
	<script src="../../../lib/stats.min.js"></script>
</head>

<body>

	<script>

		var line;
		var indice_vertice_corrente = 6;

		function Start() {
			
            //////////////////////////
            // OPERAZIONI INIZIALI //
            ////////////////////////

            // Creo una scena, una camera ed un renderer
            scene = new THREE.Scene();
			camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

            // Il renderer che useremo sarà sempre WebGL, in questo caso è impostato alla dimensione della finestra
			renderer = new THREE.WebGLRenderer({antialis:true});
			renderer.setSize(window.innerWidth, window.innerHeight);

            // Questa operazione serve per definire il colore di sfondo [grigio chiaro] che avrà l'immagine che noi creiamo
			renderer.setClearColor(0xf0f0f0);

            // ?
			document.body.appendChild(renderer.domElement);

            /////////////////////////
            // DISEGNO L'OTTAEDRO //    NB: wireframe
            ///////////////////////

            // Geometry
            const geometry = new THREE.Geometry();
			geometry.vertices.push(
				new THREE.Vector3( 0,  3,  0),  // 0  Punto in alto
				new THREE.Vector3( 0, -3,  0),  // 1  Punto in basso
				new THREE.Vector3( 0,  0,  3),  // 2
				new THREE.Vector3( 3,  0,  0),  // 3
				new THREE.Vector3(-3,  0,  0),  // 4
				new THREE.Vector3( 0,  0, -3),  // 5
			);

            geometry.faces.push(
				// 4 superiori
				new THREE.Face3(0, 2, 3),
				new THREE.Face3(0, 2, 4),
                new THREE.Face3(0, 3, 5),
                new THREE.Face3(0, 4, 5),
                // 4 inferiori
				new THREE.Face3(1, 2, 3),
				new THREE.Face3(1, 2, 4),
                new THREE.Face3(1, 3, 5),
                new THREE.Face3(1, 4, 5),
				// test
				// new THREE.Face3(0, 1, 2), // linea dal punto più alto al punto più basso
			);

            // Uso la tecnica wireframe
            var wireframe = new THREE.WireframeGeometry( geometry );
			var mat = new THREE.LineBasicMaterial( { color: "black", linewidth: 2 } );
            line = new THREE.LineSegments( wireframe, mat );

            scene.add( line );

			// IMPLEMENTAZIONE ALGORITMO RICORSIVO

			// Soluzione: itero su ogni lato
			//            itero sui 3 vertici vicini (a 2 a 2) [ES: Primo lato --> (0,2)(2,3)(3,0)]
			//			  divido per 2 e ottengo i vertici dei triangolini più piccoli all'interno
			//            aggiungo i vertici
			//            collego i vertici

			// ALGORITMO RICORSIVO V1

			for (let n = 0; n < 6; n++) {
				let numero_facce = geometry.faces.length;
				console.log("Numero totale facce al ciclo ", n, ": ", numero_facce);
				for (let i = 0; i < numero_facce; i++) {
					var a = geometry.faces[i].a;
					var b = geometry.faces[i].b;
					var c = geometry.faces[i].c;

					console.log("Faccia ", i, ": ", a,b,c);

					// Creo i cloni dei vertici che mi interessano
					var old_v1_A = geometry.vertices[a].clone();
					var old_v1_B = geometry.vertices[a].clone();
					var old_v2 = geometry.vertices[b].clone();
					var old_v3 = geometry.vertices[c].clone();

					console.log("Elenco cloni: ", old_v1_A, old_v1_B, old_v2, old_v3);

					// Ottengo i 3 nuovi vertici
					var vertex_1 = ( old_v1_A.add(old_v2) ).divideScalar(2)
					var vertex_2 = ( old_v2.add(old_v3) ).divideScalar(2)
					var vertex_3 = ( old_v3.add(old_v1_B) ).divideScalar(2)

					console.log("Elenco nuovi vertici: ", vertex_1, vertex_2, vertex_3);

					// NB: Devo conoscere il numero di indici presenti al momento

					// Aggiungo i nuovi vertici alla corrispettiva lista
					geometry.vertices.push(
						vertex_1, // indice_vertice_corrente
						vertex_2, // indice_vertice_corrente +1			
						vertex_3, // indice_vertice_corrente +2
					);

					console.log("Elenco vertici aggiunti: ", geometry.vertices)

					console.log("Primo indice da aggiungere: ", indice_vertice_corrente)

					// Aggiungo la nuova faccia alla geometria
					geometry.faces.push(
						new THREE.Face3(indice_vertice_corrente,
										indice_vertice_corrente+1, 
										indice_vertice_corrente+2
										),
						new THREE.Face3(a,
										indice_vertice_corrente,
										indice_vertice_corrente+2,
										),
						new THREE.Face3(b,
										indice_vertice_corrente,
										indice_vertice_corrente+1,
						),
						new THREE.Face3(c,
										indice_vertice_corrente+1,
										indice_vertice_corrente+2,
						),
					)

					// aggiorno il vertice corrente
					indice_vertice_corrente += 3;
					
				}
			}

			// Rimuovo i precedenti elementi dalla scena (soluzione sporca?)
			while(scene.children.length > 0){ 
				scene.remove(scene.children[0]); 
			}

			// Aggiungo la nuova geometria
			wireframe = new THREE.WireframeGeometry( geometry );
			mat = new THREE.LineBasicMaterial( { color: "black", linewidth: 2 } );
			line = new THREE.LineSegments( wireframe, mat );

			scene.add( line );


			/* IMPLEMENTAZIONE NAIVE PRIMA FACCIA (per testing) */

			/*

			// Ottengo i 3 nuovi vertici

			// Clono i 3 vertici della faccia di partenza
			var old_v1_A = geometry.vertices[0].clone();
			var old_v1_B = geometry.vertices[0].clone();
			var old_v2 = geometry.vertices[2].clone();
			var old_v3 = geometry.vertices[3].clone();

			// Ottengo i 3 nuovi vertici
			var vertex_1 = ( old_v1_A.add(old_v2) ).divideScalar(2)
			var vertex_2 = ( old_v2.add(old_v3) ).divideScalar(2)
			var vertex_3 = ( old_v3.add(old_v1_B) ).divideScalar(2)

			// Debug test [CORRETTO]
			console.log("Vertice 1: ", vertex_1) //
			console.log("Vertice 2: ", vertex_2) // valori corretti
			console.log("Vertice 3: ", vertex_3) //
			
			// Aggiungo i nuovi vertici alla corrispettiva lista
			geometry.vertices.push(
				vertex_1, // 6
				vertex_2, // 7				
				vertex_3, // 8
			);

			// Aggiorno la lista dei vertici (?) --> a quanto pare ne sto fraintendendo l'utilizzo
			// geometry.verticesNeedUpdate = true;

			// Debug test [CORRETTO]
			console.log("Vertice 1, preso da indice: ", geometry.vertices[6])
			console.log("Vertice 2, preso da indice: ", geometry.vertices[7])
			console.log("Vertice 3, preso da indice: ", geometry.vertices[8])

			// Aggiungo la nuova faccia alla geometria
			// NB: i vertici esistono, solo che non appaiono :/
			geometry.faces.push(
				new THREE.Face3(6, 7, 8), // dovrebbe aggiungere una linea dal punto più alto al più basso --> NON LO FA!
			)

			// Rimuovo i precedenti elementi dalla scena (soluzione sporca?)
			while(scene.children.length > 0){ 
    			scene.remove(scene.children[0]); 
			}

			// Aggiungo la nuova geometria
			wireframe = new THREE.WireframeGeometry( geometry );
			mat = new THREE.LineBasicMaterial( { color: "black", linewidth: 2 } );
            line = new THREE.LineSegments( wireframe, mat );

			scene.add( line );

			*/

            ////////////////////////////////
            // GESTIONE MONITORAGGIO FPS //
            //////////////////////////////
			stats = new Stats();
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.top = '1vw';
            stats.domElement.style.left = '1vw';

            // ?
			document.body.appendChild(stats.domElement);

            // Posiziono la camera lungo l'asse z, in posizione 5
			camera.position.z = 5;
		}

		var rotation = false;
		var speed = 0.002;

		function Update() {
			requestAnimationFrame(Update);

			document.addEventListener("keydown", onDocumentKeyDown, false);
			function onDocumentKeyDown(event) {
				var keyCode = event.which;
				if (keyCode == 77) {              // m
					rotation = true; 
				} else if (keyCode == 83) {       // s
					rotation = false;
				} else if (keyCode == 70) {       // f
					if (speed > 0.2) {
						speed = 0.001;
					} else {
						speed += 0.0001;
					}
				}
			};

			if (rotation) {
				line.rotation.x += speed;
            	line.rotation.y += speed;
			}

			stats.update();
			renderer.render(scene, camera);
		}
		
        Start();
		Update();

	</script>
</body>

</html>