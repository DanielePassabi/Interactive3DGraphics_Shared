<html>
	<head>
		<title>Wannabe Ottaedro</title>
		<style>

		body {
			font-family: Monospace;
			margin: 0px;
			overflow: hidden;
		}

		canvas {
			width: 100%;
			height: 100%;
		}

	</style>
		<script src="../lib/three.js"></script>
		<script src="../lib/stats.min.js"></script>
		<script src="../lib/Coordinates.js"></script>
		<script src="../lib/OrbitControls.js"></script>
	</head>
	<body>

		<script>

		var scene, camera, renderer, controls, stats;

		var line;
		var indice_vertice_corrente = 6;

		var rotation = false;
		var speed = 0.002;

		function Start() {

			//////////////////////////
            // OPERAZIONI INIZIALI //
            ////////////////////////

            // Creo una scena e ne setto il colore di background (sovrascrive il CSS)
			scene = new THREE.Scene();
			scene.background = new THREE.Color( '#b1e0e2' );

			// Creo una camera
			camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

			// Creo un renderer
			renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.setClearColor( 0xf0f0f0 );
			document.body.appendChild( renderer.domElement );

			// Setto la posizione della camera e le dico dove guardare (origine)
			camera.position.set(3,4,6);
			camera.lookAt( new THREE.Vector3(0,0,0));

            /////////////////////////
            // DISEGNO L'OTTAEDRO //    NB: wireframe
            ///////////////////////

            // Geometry
            const geometry = new THREE.Geometry();
			geometry.vertices.push(
				new THREE.Vector3( 0,  3,  0),  // 0  Punto in alto
				new THREE.Vector3( 0, -3,  0),  // 1  Punto in basso
				new THREE.Vector3( 0,  0,  3),  // 2
				new THREE.Vector3( 3,  0,  0),  // 3
				new THREE.Vector3(-3,  0,  0),  // 4
				new THREE.Vector3( 0,  0, -3),  // 5
			);

            geometry.faces.push(
				// 4 superiori
				new THREE.Face3(0, 2, 3),
				new THREE.Face3(0, 2, 4),
                new THREE.Face3(0, 3, 5),
                new THREE.Face3(0, 4, 5),
                // 4 inferiori
				new THREE.Face3(1, 2, 3),
				new THREE.Face3(1, 2, 4),
                new THREE.Face3(1, 3, 5),
                new THREE.Face3(1, 4, 5),
				// test
				// new THREE.Face3(0, 1, 2), // linea dal punto più alto al punto più basso
			);

            // Uso la tecnica wireframe
            var wireframe = new THREE.WireframeGeometry( geometry );
			var mat = new THREE.LineBasicMaterial( { color: "black", linewidth: 2 } );
            line = new THREE.LineSegments( wireframe, mat );

            scene.add( line );

			// IMPLEMENTAZIONE ALGORITMO RICORSIVO

			// Soluzione: itero su ogni lato
			//            itero sui 3 vertici vicini (a 2 a 2) [ES: Primo lato --> (0,2)(2,3)(3,0)]
			//			  divido per 2 e ottengo i vertici dei triangolini più piccoli all'interno
			//            aggiungo i vertici
			//            collego i vertici

			// ALGORITMO RICORSIVO V1

			for (let n = 0; n < 6; n++) {
				let numero_facce = geometry.faces.length;
				console.log("Numero totale facce al ciclo ", n, ": ", numero_facce);
				for (let i = 0; i < numero_facce; i++) {
					var a = geometry.faces[i].a;
					var b = geometry.faces[i].b;
					var c = geometry.faces[i].c;

					console.log("Faccia ", i, ": ", a,b,c);

					// Creo i cloni dei vertici che mi interessano
					var old_v1_A = geometry.vertices[a].clone();
					var old_v1_B = geometry.vertices[a].clone();
					var old_v2 = geometry.vertices[b].clone();
					var old_v3 = geometry.vertices[c].clone();

					console.log("Elenco cloni: ", old_v1_A, old_v1_B, old_v2, old_v3);

					// Ottengo i 3 nuovi vertici
					var vertex_1 = ( old_v1_A.add(old_v2) ).divideScalar(2)
					var vertex_2 = ( old_v2.add(old_v3) ).divideScalar(2)
					var vertex_3 = ( old_v3.add(old_v1_B) ).divideScalar(2)

					console.log("Elenco nuovi vertici: ", vertex_1, vertex_2, vertex_3);

					// NB: Devo conoscere il numero di indici presenti al momento

					// Aggiungo i nuovi vertici alla corrispettiva lista
					geometry.vertices.push(
						vertex_1, // indice_vertice_corrente
						vertex_2, // indice_vertice_corrente +1			
						vertex_3, // indice_vertice_corrente +2
					);

					console.log("Elenco vertici aggiunti: ", geometry.vertices)

					console.log("Primo indice da aggiungere: ", indice_vertice_corrente)

					// Aggiungo la nuova faccia alla geometria
					geometry.faces.push(
						new THREE.Face3(indice_vertice_corrente,
										indice_vertice_corrente+1, 
										indice_vertice_corrente+2
										),
						new THREE.Face3(a,
										indice_vertice_corrente,
										indice_vertice_corrente+2,
										),
						new THREE.Face3(b,
										indice_vertice_corrente,
										indice_vertice_corrente+1,
						),
						new THREE.Face3(c,
										indice_vertice_corrente+1,
										indice_vertice_corrente+2,
						),
					)

					// aggiorno il vertice corrente
					indice_vertice_corrente += 3;
					
				}
			}

			// Rimuovo i precedenti elementi dalla scena (soluzione sporca?)
			while(scene.children.length > 0){ 
				scene.remove(scene.children[0]); 
			}

			// Aggiungo la nuova geometria
			wireframe = new THREE.WireframeGeometry( geometry );
			mat = new THREE.LineBasicMaterial( { color: "black", linewidth: 2 } );
			line = new THREE.LineSegments( wireframe, mat );

			scene.add( line );

			/////////////////////////////////////////////
            // GESTIONE COORDINATE E MOVIMENTO CAMERA //
            ///////////////////////////////////////////
			Coordinates.drawAllAxes();

			controls = new THREE.OrbitControls( camera );

			////////////////////////////////
            // GESTIONE MONITORAGGIO FPS //
            //////////////////////////////
			stats = new Stats();
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.top = '1vw';
            stats.domElement.style.left = '1vw';
			document.body.appendChild( stats.domElement );
		}

		function Update() {
			requestAnimationFrame( Update );

			// GESTIONE ROTAZIONE
			document.addEventListener("keydown", onDocumentKeyDown, false);
			function onDocumentKeyDown(event) {
				var keyCode = event.which;
				if (keyCode == 77) {              // m
					rotation = true; 
				} else if (keyCode == 83) {       // s
					rotation = false;
				} else if (keyCode == 70) {       // f
					if (speed > 0.2) {
						speed = 0.001;
					} else {
						speed += 0.0001;
					}
				}
			};

			if (rotation) {
				line.rotation.x += speed;
            	line.rotation.y += speed;
			}

			controls.update();
			stats.update();
			Render();
		}

		function Render() {
			renderer.render(scene, camera);
		}

		Start();
		Update();

		</script>
	</body>
</html>
