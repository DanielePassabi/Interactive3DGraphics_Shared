<html>

<head>
	<title>Ottaedro</title>
	<style>
		body {
			font-family: Monospace;
			background-color: #baf2ea;
			margin: 0px;
			overflow: hidden;
		}
		canvas {
			width: 100%;
			height: 100%;
		}
	</style>
	<script src="../../../lib/three.min.js"></script>
	<script src="../../../lib/stats.min.js"></script>
</head>

<body>

	<script>

		var ottaedro;
		var indice_vertice_corrente = 6;
		var origine = new THREE.Vector3(0,0,0);

		function Start() {
			
            //////////////////////////
            // OPERAZIONI INIZIALI //
            ////////////////////////

            // Creo una scena, una camera ed un renderer
            scene = new THREE.Scene();
			camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

            // Il renderer che useremo sarà sempre WebGL, in questo caso è impostato alla dimensione della finestra
			renderer = new THREE.WebGLRenderer({antialis:true});
			renderer.setSize(window.innerWidth, window.innerHeight);

            // Questa operazione serve per definire il colore di sfondo [grigio chiaro] che avrà l'immagine che noi creiamo
			renderer.setClearColor(0xf0f0f0);

            // ?
			document.body.appendChild(renderer.domElement);

            /////////////////////////
            // DISEGNO L'OTTAEDRO //    NB: wireframe
            ///////////////////////

            // Geometry
            const geometry = new THREE.Geometry();
			geometry.vertices.push(
				new THREE.Vector3( 0,  2,  0),  // 0  Punto in alto
				new THREE.Vector3( 0, -2,  0),  // 1  Punto in basso
				new THREE.Vector3( 0,  0,  2),  // 2
				new THREE.Vector3( 2,  0,  0),  // 3
				new THREE.Vector3(-2,  0,  0),  // 4
				new THREE.Vector3( 0,  0, -2),  // 5
			);

            geometry.faces.push(
				// 4 superiori
				new THREE.Face3(0, 2, 3),
				new THREE.Face3(0, 2, 4),
                new THREE.Face3(0, 3, 5),
                new THREE.Face3(0, 4, 5),
                // 4 inferiori
				new THREE.Face3(1, 2, 3),
				new THREE.Face3(1, 2, 4),
                new THREE.Face3(1, 3, 5),
                new THREE.Face3(1, 4, 5),
				// test
				// new THREE.Face3(0, 1, 2), // linea dal punto più alto al punto più basso
			);

            // Uso la tecnica wireframe
            var wireframe = new THREE.WireframeGeometry( geometry );
			var mat = new THREE.LineBasicMaterial( { color: "black", linewidth: 2 } );
            ottaedro = new THREE.LineSegments( wireframe, mat );

            scene.add( ottaedro );

			// IMPLEMENTAZIONE ALGORITMO RICORSIVO

			// Soluzione: itero su ogni lato
			//            itero sui 3 vertici vicini (a 2 a 2) [ES: Primo lato --> (0,2)(2,3)(3,0)]
			//			  divido per 2 e ottengo i vertici dei triangolini più piccoli all'interno
			//            aggiungo i vertici
			//            collego i vertici

			// ALGORITMO RICORSIVO V1

			for (let n = 0; n < 6; n++) {
				let numero_facce = geometry.faces.length;
				console.log("Numero totale facce al ciclo ", n, ": ", numero_facce);
				for (let i = 0; i < numero_facce; i++) {
					var a = geometry.faces[i].a;
					var b = geometry.faces[i].b;
					var c = geometry.faces[i].c;

					console.log("Faccia ", i, ": ", a,b,c);

					// Creo i cloni dei vertici che mi interessano
					var old_v1_A = geometry.vertices[a].clone();
					var old_v1_B = geometry.vertices[a].clone();
					var old_v2 = geometry.vertices[b].clone();
					var old_v3 = geometry.vertices[c].clone();

					console.log("Elenco cloni: ", old_v1_A, old_v1_B, old_v2, old_v3);

					// Ottengo i 3 nuovi vertici
					var vertex_1 = ( old_v1_A.add(old_v2) ).divideScalar(2);
					var vertex_2 = ( old_v2.add(old_v3) ).divideScalar(2);
					var vertex_3 = ( old_v3.add(old_v1_B) ).divideScalar(2);

					// Trovo le distanze dal centro
					var dist1 = vertex_1.distanceTo(origine);
					var dist2 = vertex_2.distanceTo(origine);
					var dist3 = vertex_3.distanceTo(origine);

					// Debug distanze
					console.log("DISTANZE: ", dist1, dist2, dist3);

					// Valore correttivo
					var delta1 = 2/dist1;
					var delta2 = 2/dist2;
					var delta3 = 2/dist3;

					// Normalizzo la posizione dei vertici
					vertex_1.x = vertex_1.x*delta1;
					vertex_2.x = vertex_2.x*delta1;
					vertex_3.x = vertex_3.x*delta1;
					vertex_1.y = vertex_1.y*delta2;
					vertex_2.y = vertex_2.y*delta2;
					vertex_3.y = vertex_3.y*delta2;
					vertex_1.z = vertex_1.z*delta3;
					vertex_2.z = vertex_2.z*delta3;
					vertex_3.z = vertex_3.z*delta3;

					// Ricalcolo le distanze (per debug) e le stampo su console
					dist1 = vertex_1.distanceTo(origine);
					dist2 = vertex_1.distanceTo(origine);
					dist3 = vertex_1.distanceTo(origine);
					console.log("DISTANZE NUOVE: ",dist1,dist2,dist3);

					// Stampo i nuovi vertici
					console.log("Elenco nuovi vertici: ", vertex_1, vertex_2, vertex_3);

					// NB: Devo conoscere il numero di indici presenti al momento

					// Aggiungo i nuovi vertici alla corrispettiva lista
					geometry.vertices.push(
						vertex_1, // indice_vertice_corrente
						vertex_2, // indice_vertice_corrente +1			
						vertex_3, // indice_vertice_corrente +2
					);

					console.log("Elenco vertici aggiunti: ", geometry.vertices)

					console.log("Primo indice da aggiungere: ", indice_vertice_corrente)

					// Devo rimuovere la faccia
					geometry.faces[i] = new THREE.Face3(indice_vertice_corrente,
										indice_vertice_corrente+1, 
										indice_vertice_corrente+2
										)

					// Aggiungo la nuova faccia alla geometria
					geometry.faces.push(
						//new THREE.Face3(indice_vertice_corrente,
						//				indice_vertice_corrente+1, 
						//				indice_vertice_corrente+2
						//				),
						new THREE.Face3(a,
										indice_vertice_corrente,
										indice_vertice_corrente+2,
										),
						new THREE.Face3(b,
										indice_vertice_corrente,
										indice_vertice_corrente+1,
						),
						new THREE.Face3(c,
										indice_vertice_corrente+1,
										indice_vertice_corrente+2,
						),
					)

					// aggiorno il vertice corrente
					indice_vertice_corrente += 3;
					
				}
			}

			// Rimuovo i precedenti elementi dalla scena (soluzione sporca?)
			while(scene.children.length > 0){ 
				scene.remove(scene.children[0]); 
			}

			// Aggiungo la nuova geometria
			wireframe = new THREE.WireframeGeometry( geometry );
			mat = new THREE.LineBasicMaterial( { color: "black", linewidth: 2 } );
			ottaedro = new THREE.LineSegments( wireframe, mat );

			scene.add( ottaedro );

            ////////////////////////////////
            // GESTIONE MONITORAGGIO FPS //
            //////////////////////////////
			stats = new Stats();
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.top = '1vw';
            stats.domElement.style.left = '1vw';

            // ?
			document.body.appendChild(stats.domElement);

            // Posiziono la camera lungo l'asse z, in posizione 5
			camera.position.z = 5;
		}

		var rotation = false;
		var speed = 0.002;

		function Update() {
			requestAnimationFrame(Update);

			document.addEventListener("keydown", onDocumentKeyDown, false);
			function onDocumentKeyDown(event) {
				var keyCode = event.which;
				if (keyCode == 77) {              // m
					rotation = true; 
				} else if (keyCode == 83) {       // s
					rotation = false;
				} else if (keyCode == 70) {       // f
					if (speed > 0.2) {
						speed = 0.001;
					} else {
						speed += 0.0001;
					}
				}
			};

			if (rotation) {
				ottaedro.rotation.x += speed;
            	ottaedro.rotation.y += speed;
			}

			stats.update();
			renderer.render(scene, camera);
		}
		
        Start();
		Update();

	</script>
</body>

</html>